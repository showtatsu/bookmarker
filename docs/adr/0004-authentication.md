---
name: authentication
description: 'Authentication Strategy for Bookmarker Application'
status: accepted
---

## タイトル
認証方式の選定

## 概要
Bookmarkerアプリケーションにおけるユーザー認証方式に関する決定事項です。

## 背景
マルチユーザー対応アプリケーションとして、セキュアなユーザー認証とAPIアクセス制御が必要です。Webブラウザからのアクセスと、外部ツールからのAPI呼び出しの両方に対応する必要があります。

## 決定事項

### 認証方式: パスワード または OpenID Connect によるサインイン、その後 JWT（JSON Web Token） を発行して認証を行う

#### Webアプリケーション認証

- **アクセストークン**:
  - 有効期限: 15分
  - ペイロード: `{ userId, username, iat, exp }`
  - HTTPOnly Cookie に格納

- **リフレッシュトークン**:
  - 有効期限: 7日
  - HTTPOnly Cookie に格納
  - データベースでトークンハッシュを管理（無効化対応）

#### OpenID Connect サインイン/サインアップ
- 外部IDプロバイダ（Keycloakなど）を利用
- OAuth 2.0 Authorization Code Flow を使用
- ユーザー情報を取得し、Bookmarkerのユーザープロファイルと紐付け
- OpenID Connectでの認証後、JWTアクセストークンとリフレッシュトークンを発行

#### API トークン認証

- 長期有効なAPIトークンを発行（ユーザーが有効期限を設定可能）
- `Authorization: Bearer <token>` ヘッダーで認証
- トークンはハッシュ化してデータベースに保存

### パスワード管理

- **ハッシュ化**: bcryptjs（コストファクター: 12）
- **パスワード要件**:
  - 最小8文字
  - 大文字・小文字・数字を含む

### 認証フロー

```
[ログイン]
1. POST /api/auth/login { username, password }
2. パスワード検証（bcrypt.compare）
3. アクセストークン + リフレッシュトークン発行
4. HTTPOnly Cookie にトークンを設定
5. ユーザー情報をレスポンス

[トークンリフレッシュ]
1. POST /api/auth/refresh
2. リフレッシュトークン検証
3. 新しいアクセストークン発行

[ログアウト]
1. POST /api/auth/logout
2. Cookie からトークン削除
3. リフレッシュトークンを無効化（DB）

[APIトークン認証]
1. リクエストヘッダー Authorization: Bearer <token>
2. トークンハッシュをDBで検索
3. 有効期限とユーザー検証
4. last_used_at を更新
```

### ミドルウェア実装

```typescript
// 認証ミドルウェア
export const authenticate = async (req, res, next) => {
  // 1. Cookie からアクセストークン取得
  // 2. または Authorization ヘッダーからAPIトークン取得
  // 3. トークン検証
  // 4. req.user にユーザー情報を設定
  // 5. next() または 401 エラー
};
```

## 代替案

| 案 | 利点 | 欠点 | 判断 |
|---|---|---|---|
| JWT（採用） | ステートレス、スケーラブル | トークン無効化に工夫が必要 | リフレッシュトークンで対応 |
| セッション | シンプル、即時無効化可能 | サーバー側でセッション管理必要 | スケーラビリティの観点から不採用 |
| OAuth 2.0 | 標準的、外部プロバイダ連携 | 実装複雑、個人利用には過剰 | 将来的な拡張として検討 |

## 結果
JWT認証により、ステートレスなAPI設計が可能になり、フロントエンドとバックエンドの分離が容易になります。

### 負荷分散対応

JWT認証のステートレス設計により、以下の利点があります：

- **水平スケーラビリティ**: 複数のバックエンドインスタンスに負荷分散可能
- **セッション共有不要**: サーバー側でセッション状態を保持しないため、インスタンス間でのセッション共有が不要
- **スティッキーセッション不要**: どのバックエンドインスタンスでもリクエストを処理可能
- **高可用性**: 一部のインスタンスが停止しても、他のインスタンスで処理を継続

#### 注意事項

- **JWT_SECRET**: すべてのバックエンドインスタンスで同一のJWT_SECRETを使用する必要があります
- **リフレッシュトークン**: データベースで管理されるため、データベースへのアクセスが必要です（負荷分散時は共有データベースを使用）

## 関連ドキュメント
- [ADR-0005: API設計方針](0005-api-design.md)
- [ADR-0010: セキュリティ対策方針](0010-security.md)
